GOALS
    Lightweight request/response protocol
    Transport agnostic: bluetooth, UDP
    No heap allocations in C client/server
    Compile-time packet size/buffer overrides
    Basic authentication
    Encryption support
    Client-driven version selection

NON-GOALS
    Session state (intially)
    Detailed Authn/Authz
    Bidirectional communication

Initial implementation
    64-byte packets by default
        64K max packets
    encryption optional for tiny platforms
        PSK AES?
    16 byte block alignment for encryption

    v0.1
        encryption envelope
            2 byte: session id
            2 byte: padded length
        header
            1 byte: protocol version id
            1 byte: RPC #
            2 byte: request id
            2 byte: data length
            1 byte: Flags (bit field)
                bit 0: request/reply
                bit 1: error
            1 byte: CRC8 of header; alignment verification
        data
    v0.2
        Encryption envelope
            ? protocol version id
            4 byte: client id
            2 byte: payload length
            1 byte: CRC8
            1 byte: reserved
        ? protocol version id
        2 byte: payload length
        2 byte: request id
        1 byte: RPC #
        1 byte: Flags (bit field)
            bit 0: request/reply
            bit 1: error
        1 byte: reserved
        1 byte: CRC8 of header; alignment verification

        encrypted: bytes 16-63 payload
        raw: bytes 8-63: payload
    v0.3
        encryption envelope
            4 byte id; client id on reg, session id follows
        1 protocol version id
        2 byte: payload length
        2 byte: request id
        1 byte: RPC #
        1 byte: Flags (bit field)
            bit 0: request/reply
            bit 1: error
        1 byte: CRC8 of header; alignment verification


    Registration call
        Reserved RPC
            initial call and response are tied to protocol version
        rpc #0
        payload is registration config/params
        response
            sucess/fail:
                OK if magic and version check out
                "Unsupported version" if magic checks, but ver does not
                No response if magic fails to disrupt encryption / auth attacks
            capabilities:
                Encryption enabled?
    Security
        Session ID
            *to be time-tracked in later implementations
            Randomly generated
            returned as part of registration
        Resistance to replay attacks?
            embedded environment limits tools such as MAC
        Only care about encrypted packets on network connections?
    CRC polynomial selection
        http://users.ece.cmu.edu/~koopman/roses/dsn04/koopman04_crc_poly_embedded.pdf
        CRC-8 poly: 0xEA, 0x97 0x96*

protocol revamp
    (message) read message
    read id, length
    read 16 byte chunk
    decrypt and verify header
        on error
            reply
            (stream) close socket
    Client keys
        client id sent in registration data
        key selected from server database
        session id created and key associated

