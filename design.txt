GOALS
    Lightweight request/response protocol
    Transport agnostic: bluetooth, UDP
    No heap allocations in C client/server
    Compile-time packet size/buffer overrides
    Basic authentication
    Encryption support
    Client-driven version selection
    Bidirectional communication

NON-GOALS
    Session state (intially)
    Detailed Authn/Authz

Initial implementation
    64-byte packets by default
        64K max packets
    encryption optional for tiny platforms
        PSK AES
    16 byte block alignment for encryption

    RPC frame
        encryption envelope
            1 byte: version
            1 byte: protocol flags
                bit 0: encryption; default 1, encrypted
                bit 1-?: encryption algorithm; default 0, AES
            4 byte: key id (session)
        2 byte: payload length
        2 byte: request id
        1 byte: RPC #
        1 byte: Flags (bit field)
            bit 0: request/reply
            bit 1: control/user RPC
            bit 2: error
        1 byte: CRC8 of payload
        1 byte: CRC8 of header; alignment verification

    Registration call
        Control RPC
            initial call and response are tied to protocol version
        rpc #0
        request
            session is 0x0.
            payload is client id, registration config/params
        response
            encryption key looked up via client id
            random session id chosen
            sucess/fail:
                OK if CRC and version check out
                "Unsupported version" if CRC checks, but ver does not
                No response if CRC fails to disrupt encryption / auth attacks
    Security
        AES encryption by default
        point to point implementations will perform challenge response
    CRC polynomial selection
        http://users.ece.cmu.edu/~koopman/roses/dsn04/koopman04_crc_poly_embedded.pdf
        CRC-8 poly: 0xEA, 0x97 0x96*

Use cases

We several possible scenarios that can be deployed in hardware: Transceivers on
both ends, transmit-only devices, and receive-only devices.

    Client to server
        The standard platform. Example scenarios include:
            Data collecton embedded devices reporting back to a large
                server/cluster.
            Large clients pushing data and commands to embedded control and
                display devices.
            Embedded devices connecting out to internet servers and receiving
                commands. The client/server roles being effectively swapped to
                work around devices behind firewalls and ephemeral IPs.
        Client initiates conenction to server
        3-way challenge-response to negotiate session id, possibly session key
        Streaming responses possible by sending multiple frames with the reply
            bit set and the same request id.
    Unidirectional
        Some implementations may have transmit-only and receive-only devices:
            Key fobs talking to base stations; the fob (client) broadcasting 
                to the base station (server).
            Base stations broadcasting to embedded control devices, e.g. smart
                lights, curtain controls, other home automation
        The frame key id directly maps to a pre-shared key
            This allows for approximately 4.2 billion pre-shared keys. We can
            expand this space for more devices by utilizing a client id in the
            payload. Devices will ignore anything that does not match their
            frame key, decrypt frames that do, and only react to frames that
            contain their 128 bit client id.
        The API should handle security using something very similar to RKE.
            Internal counters on each device will be set to a random number on
            initial synchronization. An error window of 50-100 with a resync
            window of 1000.

